Ideas around gegl-server and GEGL+web.

Overview
=========

== Possible usecases ==
UC1: Non-interactive image processing as a service for web or local clients.
UC2: Interactive (real-time) image processing in native/local applications
     which are implemented using web technologies (Javascript, HTML5)
UC3: Interactive (real-time) image processing in web applications
UC4: Serving of image buffers/tiles to web-clients from massively tiled
     data storage like for maps.
     
UC1 is by far the simplest, and is the usecase targeted by gegl-server at the moment.

UC2 will require the majority of the GEGL API to be exposed in a two-way
fashion over a client<->server side transport. Including listing of operations,
graph manipulation

UC3 will require client-side image processing to be possible. Only making use
of server side processing will make latency unacceptably high. When user commits
a change, the change will be transmitted to server side as a series of graph changes.
This will allow the server to render an output of the document, as well as allowing
it to be a syncronization for multiple peers operating on the same document.


Topics
========

== Caching of processed data ==
Currently GEGL makes heavy use of (in-memory) caching when manipulating
the graph. This means that if one adds a new node to the end of the
graph, only that node needs to be processed.
This requires that the graphs are long-lived on the server side, and a
mapping exists between the server and client side 

As a GEGL graph is a full description of a composition with deterministic
results. This only makes sense if processing the graph is more expensive
than fetching it from disk.

== Imperative API for clients ==

Required API

Graph transaction
* Start/Open transaction
* End/Commit transaction

Graph
* Create graph
* Create node
* Set node properties
* Get node properties
* Connect pads
* Disconnect pads
* Delete node

Graph serialization/deseriazation
* Create from JSON / XML
* Save to JSON / XML

Operations
* List valid operations
* Get valid properties of operation

Processing
* Process node to a PNG/JPEG file
* Process node tile-wise
* Process node continiously and only get updated tiles


Possible implementation paths:
* Handwrite a Javascript client library, and server code.
  Tedious, but encourages one to think about how the consumer 
  would want to use the API.
* Extend node-gir to be able to generate a Javascript client library.
  Very big and generic. Risk of introducing impedance mismatch,
  as the current GEGL C API may be far from how one would want to
  make use of the functionality in a client-server Javascript system.
  
Transport system:
* socket.io, sockJS or JSON-RPC? With the latter only the client can
  initiate communication.

== Client-side image processing ==
Doing processing server-side and transferring to client-side
incurrs a significant latency. To allow real-time feedback on-canvas
when changing parameters in the graph, the client would render
the preview while the user is changing the parameters. And then, when
the user has "committed" these parameters the server will process it.

Possible implementation paths:
* Use the openCL code found in GEGL operations and execute them client side
- Khronos WebCL : http://www.khronos.org/webcl/ ?
- Pure javascript openCL implementation? maybe based on LLVM IR?

* Compatibility layer on top of existing web graphics processing library ?
- dojox.gfx: http://dojotoolkit.org/reference-guide/dojox/gfx.html ?

* Compile GEGL (operations) and dependencies directly to Javascript?
- Emscripten:  http://emscripten.org/ ?

